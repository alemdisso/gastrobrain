================================================================================
GASTROBRAIN RECOMMENDATION ENGINE ARCHITECTURE
================================================================================

LAYER 1: DATABASE ACCESS
├── DatabaseHelper.getRecipeIngredients(recipeId)
│   └── Returns: List<Map<String, dynamic>> with protein_type field
│
└── RecommendationDatabaseQueries
    ├── getRecipeProteinTypes(recipeIds) ─────┐
    │   │ Input: List<String> recipeIds      │
    │   │ Process:                            │
    │   │  1. For each recipe:               │
    │   │  2.   Get ALL ingredients         │
    │   │  3.   Extract protein_type field  │
    │   │  4.   Collect in List<PT>         │
    │   │ Output: Map<recipeId, [PT, PT]>   │
    │   └─────────────────────────────────────┘
    │
    ├── getRecentMeals(dateRange, limit)
    │   │ Loads 20 meals (14-day lookback)
    │   │ Returns primary recipe only
    │   └── Output: List<{meal, recipe, cookedAt}>
    │
    ├── getMealCounts(recipeIds)
    │   │ Aggregates times cooked per recipe
    │   └── Output: Map<recipeId, count>
    │
    └── getCandidateRecipes(filters)
        │ Apply protein filters with .any() logic
        └── Output: List<Recipe>


LAYER 2: CONTEXT BUILDING
┌─────────────────────────────────────────────────────────────┐
│ RecommendationService._buildContext()                       │
│                                                              │
│ Collects data needed by factors:                           │
│                                                              │
│ ├─ For ProteinRotationFactor:                              │
│ │  ├─ proteinTypes: Map<recipeId, List<ProteinType>>      │
│ │  └─ recentMeals: List<{meal, recipe, cookedAt}>         │
│ │                                                           │
│ ├─ For FrequencyFactor:                                    │
│ │  └─ lastCooked: Map<recipeId, DateTime?>                │
│ │                                                           │
│ ├─ For VarietyEncouragementFactor:                         │
│ │  └─ mealCounts: Map<recipeId, int>                       │
│ │                                                           │
│ └─ Other:                                                   │
│    ├─ excludeIds, avoidProteinTypes, etc.                 │
│    └─ feedbackHistory, randomSeed, etc.                    │
│                                                              │
└─────────────────────────────────────────────────────────────┘


LAYER 3: RECOMMENDATION FACTORS
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  ProteinRotationFactor (30% weight)                             │
│  ├─ Input: Recipe + context['proteinTypes'] + context['recent │
│  │ Meals']                                                      │
│  ├─ Process:                                                    │
│  │  1. Get proteins: [PT.beef, PT.chicken, PT.beef]           │
│  │  2. Filter main: [PT.beef, PT.chicken, PT.beef]            │
│  │  3. For each:                                               │
│  │     ├─ Look up recent usage from recentMeals              │
│  │     └─ Apply penalty from _daysPenalty map               │
│  │  4. Average penalties                                       │
│  │  5. Calculate: 100 - (avg_penalty * 100)                  │
│  └─ Output: Score 0-100                                        │
│                                                                  │
│  VarietyEncouragementFactor (10% weight)                        │
│  ├─ Input: Recipe + context['mealCounts']                      │
│  ├─ Process: score = 100 * exp(-0.07 * cookCount)            │
│  └─ Output: Score 0-100                                        │
│                                                                  │
│  [FrequencyFactor] [RatingFactor] [DifficultyFactor] [...]     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘


LAYER 4: SCORING & RANKING
┌─────────────────────────────────────────────────────────────┐
│ For each Recipe:                                             │
│                                                              │
│  factorScores = {                                           │
│    'frequency': 85.0,                                       │
│    'protein_rotation': 25.0,  ← Multi-ingredient impact    │
│    'rating': 80.0,                                          │
│    'variety_encouragement': 100.0,                          │
│    ...                                                       │
│  }                                                           │
│                                                              │
│  weightedScore = Σ(score * weight / 100)                    │
│                = (85 * 0.35) + (25 * 0.30) + ...            │
│                = Final score for ranking                     │
│                                                              │
└─────────────────────────────────────────────────────────────┘


================================================================================
MULTI-INGREDIENT RECIPE FLOW EXAMPLE
================================================================================

RECIPE: "Chicken & Beef Stir Fry"
├─ Ingredient 1: Chicken Breast (protein_type: 'chicken')
├─ Ingredient 2: Beef Stock (protein_type: 'beef')
├─ Ingredient 3: Soy Sauce (protein_type: null)
└─ Ingredient 4: Vegetables (protein_type: null)

↓

STEP 1: getRecipeIngredients()
┌────────────────────────────────────┐
│ SQL LEFT JOIN results:             │
├────────────────────────────────────┤
│ [{protein_type: 'chicken', ...},   │
│  {protein_type: 'beef', ...},      │
│  {protein_type: null, ...},        │
│  {protein_type: null, ...}]        │
└────────────────────────────────────┘

↓

STEP 2: getRecipeProteinTypes()
┌──────────────────────────────────────┐
│ Extract & collect proteins:          │
│ ├─ 'chicken' → ProteinType.chicken  │
│ ├─ 'beef' → ProteinType.beef        │
│ └─ Skip null entries                │
├──────────────────────────────────────┤
│ Result:                              │
│ context['proteinTypes'] = {          │
│   'recipe-123': [                    │
│     ProteinType.chicken,            │
│     ProteinType.beef                │
│   ]                                  │
│ }                                    │
└──────────────────────────────────────┘

↓

STEP 3: ProteinRotationFactor.calculateScore()
┌─────────────────────────────────────────────────────┐
│ Get proteins from context:                          │
│ [ProteinType.chicken, ProteinType.beef]            │
│                                                      │
│ Both are main proteins, keep both                   │
│                                                      │
│ Check recent meals:                                 │
│ ├─ Chicken used 2 days ago → 75% penalty          │
│ └─ Beef NOT in recent meals → 0% penalty           │
│                                                      │
│ Calculate:                                          │
│ ├─ Penalties: [75%, 0%]                            │
│ ├─ Average: 37.5%                                   │
│ └─ Score: 100 - (0.375 * 100) = 62.5               │
└─────────────────────────────────────────────────────┘

↓

FINAL SCORE: 62.5 (from protein rotation)
           × Other factors applied
           = Final recommendation ranking

================================================================================
POTENTIAL ISSUE: DUPLICATE PROTEINS
================================================================================

RECIPE: "Beef Ragù with Beef Stock"
├─ Ingredient 1: Beef (protein_type: 'beef')
└─ Ingredient 2: Beef Stock (protein_type: 'beef')

↓ getRecipeProteinTypes()

proteinTypes['recipe-123'] = [
  ProteinType.beef,  ← From ingredient 1
  ProteinType.beef   ← From ingredient 2 (DUPLICATE)
]

↓ ProteinRotationFactor.calculateScore()

mainProteins = [
  ProteinType.beef,  ← Iteration 1
  ProteinType.beef   ← Iteration 2
]

recentProteinUsage = {
  ProteinType.beef: 1  ← Used 1 day ago (100% penalty)
}

Penalty application:
├─ mainProteins[0] (beef): 100% penalty
├─ mainProteins[1] (same beef): 100% penalty again ⚠️
└─ Average: (100 + 100) / 2 = 100%
└─ Score: 0.0

⚠️ ISSUE: Duplicate counted twice, harsher penalty than intended

EXPECTED (if deduplicated):
├─ mainProteins = Set<ProteinType> {ProteinType.beef}
├─ Penalty: 100%
└─ Score: 0.0

RESULT: Same in this case, but different if:
  - Beef used 2 days ago (75% penalty)
  - Duplicate: (75 + 75) / 2 = 75% (incorrect)
  - Deduplicated: 75% (correct)

================================================================================
